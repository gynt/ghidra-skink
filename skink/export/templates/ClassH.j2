{% from "macros/wrap_namespaces.j2" import wrap_namespaces with context %}
{% from "macros/includes.j2" import includes %}
{%- set ns = (namespace_path.split('::') if namespace_path is string else namespace_path)
              | reject('equalto','') | list -%}

#pragma once

{{ includes(include_paths) }}

{# Do NOT pass `caller` hereâ€”it's injected implicitly by `call` #}
{%- call wrap_namespaces(ns) -%}
// SIZE: {{ "0x%08X" % class_size }}
class {{ class_name }} : public {{ struct_name }}
{
  public:
    {{ class_name }}({{ class_name }} const&) = delete;
    void operator=({{ class_name }} const&) = delete;
  private:
    {{ class_name }}();
    ~{{ class_name }}();
  
    // Use these to call the original functions
    {% for method in methods %}
    {{ method.returnType }} _{{ method.name }}({{ method.parameters | join(', ') }});
    {% endfor %}
  
  public:
    {% for method in methods %}
    {{ method.returnType }} {{ method.name }}({{ method.parameters | join(', ') }});
    {% endfor %}
  

};

static_assert(sizeof({{ class_name }}) == {{ class_size }});

{% for method in methods %}
MemberFunctionPointer_DefineThiscall_oneliner({{ class_name }}, {{ method.name }}, {{ method.returnType }}{{ ', ' + method.parameters | join(', ') if method.parameters else '' }});
{% endfor %}

{%- endcall -%}
