{% from "macros/wrap_namespaces.j2" import wrap_namespaces with context %}
{% from "macros/includes.j2" import includes %}
{% from "macros/usings.j2" import usings %}
{%- set ns = (namespace_path.split('::') if namespace_path is string else namespace_path)
              | reject('equalto','') | list -%}

#pragma once

{{ '#include "pch.h"' if use_pch }}

{{ includes(include_paths) }}

{# Do NOT pass `caller` hereâ€”it's injected implicitly by `call` #}
{%- call wrap_namespaces(ns) -%}

{{ usings(using_paths) }}


class _{{ class_name }}
{
  private:
    _{{ class_name }}(_{{ class_name }} const&);
    void operator=(_{{ class_name }} const&);
{# This only works in higher version of C++ #}
{#  public: #}
{#    _{{ class_name }}(_{{ class_name }} const&) = delete; #}
{#    void operator=(_{{ class_name }} const&) = delete; #}
{#  private: #}
    _{{ class_name }}();
    ~_{{ class_name }}();
  
  public:
    // These are here to satisfy the C++ compiler, don't use them
    {% for method in methods %}
    virtual {{ method.returnType }} _{{ method.name }}({{ method.parameters | join(', ') }}) = 0;
    {% endfor %}
  
};

{%- endcall -%}
