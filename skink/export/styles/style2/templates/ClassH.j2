{% from "macros/wrap_namespaces.j2" import wrap_namespaces with context %}
{% from "macros/includes.j2" import includes %}
{% from "macros/usings.j2" import usings %}
{%- set ns = (namespace_path.split('::') if namespace_path is string else namespace_path)
              | reject('equalto','') | list -%}

#pragma once

{{ '#include "pch.h"' if use_pch }}

{{ includes(include_paths) }}

{# Do NOT pass `caller` hereâ€”it's injected implicitly by `call` #}
{%- call wrap_namespaces(ns) -%}

{{ usings(using_paths) }}

#pragma pack(push, 1)

// SIZE: {{ "0x%08X" % class_size }}
class {{ class_name }}
{
  public:
    {% for field in fields -%}
    {{ field.string }}; // {{ '0x%08X' % field.offset }} length: {{ field.length }}
    {% endfor %}  
  private:
    {{ class_name }}({{ class_name }} const&);
    void operator=({{ class_name }} const&);
{# This only works in higher version of C++ #}
{#  public: #}
{#    {{ class_name }}({{ class_name }} const&) = delete; #}
{#    void operator=({{ class_name }} const&) = delete; #}
{#  private: #}
    {{ class_name }}();
    ~{{ class_name }}();
   
  public:
    {% for method in methods %}
    __declspec(noinline) {{ method.returnType }} {{ method.name }}({{ method.parameters | join(', ') }});
    {% endfor %}
  
    {% if is_singleton %}
    #ifdef {{ ifdef_expose_original }}
    static {{ class_name }} * const _getInstance() {
      return (({{ class_name }} * const) ADDRESS_{{ context.abbreviation }}_{{ context.hash }}_{{ '0x%08X' % singleton_address }});
    }
    #endif

    #define {{ singleton_name }} ( * {{ namespace_path }}::{{ class_name }}::getInstance())
    static {{ class_name }} * const getInstance() {
    #ifdef DECLARE_SINGLETON_{{ (ns | join('_')) }}_{{ class_name }}
      static {{ class_name }} instance;
      return &instance;
    #else
      return {{ class_name }}::_getInstance();
    #endif
    }
    
    {% endif %}

  #ifdef {{ ifdef_expose_original }}
  {% if expose_original_methods %}
  public:
  {% else %}
  private:
  {% endif %}
    // Use these to call the original functions
    {% for method in methods %}
    __declspec(noinline) inline {{ method.returnType }} _{{ method.name }}({{ method.parameters | join(', ') }}) {
      {% set addr = 'ADDRESS_' + context.abbreviation + '_' + context.hash + '_' + ('0x%08X' % method.address ) -%}
      {%- set all_parameters = [class_name + " * _this"] + method.parameters -%}
      {%- set all_parameter_names = ["this"] + method.parameter_names -%}
      return (({{ method.returnType }} (__thiscall * const)({{ all_parameters | join(', ') }})) {{ addr }})({{ all_parameter_names | join(', ') }});
    };
    {% endfor %}
  #endif
};

static_assert_cpp98_obj(sizeof({{ class_name }}) == {{ class_size }}, {{ class_name }});

#pragma pack(pop)

{%- endcall -%}
